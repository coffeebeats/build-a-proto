//! Rust code generator implementation.
//!
//! Generates Rust structs, enums, and stub encode/decode methods from IR schemas.

use std::path::PathBuf;

use crate::generate::generator::Generator;
use crate::generate::{CodeWriter, CodeWriterBuilder, Writer};
use crate::ir;

/* -------------------------------------------------------------------------- */
/*                               Struct: Rust                                 */
/* -------------------------------------------------------------------------- */

#[derive(Clone, Debug)]
pub struct Rust(CodeWriter);

/* ------------------------------ Impl: Default ----------------------------- */

impl Default for Rust {
    fn default() -> Self {
        Self(
            CodeWriterBuilder::default()
                .comment_token("///".to_owned())
                .indent_token("    ".to_owned())
                .newline_token("\n".to_owned())
                .build()
                .unwrap(),
        )
    }
}

/* ----------------------------- Impl: Generator ---------------------------- */

impl<W: Writer> Generator<W> for Rust {
    fn configure_writer(
        &self,
        out_dir: &std::path::Path,
        pkg: &ir::Package,
    ) -> anyhow::Result<PathBuf> {
        let parts: Vec<&str> = pkg.path.split('.').collect();
        let mut path = out_dir.to_path_buf();

        // Build nested directory structure for all but last segment
        for part in &parts[..parts.len().saturating_sub(1)] {
            path.push(part);
        }

        // Last segment becomes the filename
        if let Some(last) = parts.last() {
            path.push(format!("{}.rs", last));
        }

        Ok(path)
    }

    fn gen_begin(
        &mut self,
        _: &ir::Schema,
        _: Vec<(&std::path::PathBuf, &mut W)>,
    ) -> anyhow::Result<()> {
        Ok(())
    }

    fn gen_end(
        &mut self,
        _: &ir::Schema,
        _: Vec<(&std::path::PathBuf, &mut W)>,
    ) -> anyhow::Result<()> {
        Ok(())
    }

    fn pkg_begin(
        &mut self,
        _: &ir::Schema,
        pkg: &ir::Package,
        w: &mut W,
    ) -> anyhow::Result<()> {
        // File header
        self.0.writeln(
            w,
            &format!("//! Generated code for package `{}`.", pkg.path),
        )?;
        self.0.writeln(w, "//!")?;
        self.0.writeln(w, "//! This file was automatically generated by baproto.")?;
        self.0.writeln(w, "//! Do not edit manually.")?;
        self.0.blank_line(w)?;

        // Imports
        self.0.writeln(w, "use std::collections::HashMap;")?;
        self.0.writeln(w, "use std::io::{Read, Write};")?;
        self.0.blank_line(w)?;

        Ok(())
    }

    fn pkg_end(&mut self, _: &ir::Schema, _: &ir::Package, _w: &mut W) -> anyhow::Result<()> {
        // No footer needed for Rust files
        Ok(())
    }

    fn gen_include(
        &mut self,
        _: &ir::Schema,
        dep_pkg: &ir::Package,
        w: &mut W,
    ) -> anyhow::Result<()> {
        // Convert package path to Rust use statement
        let rust_path = dep_pkg.path.replace('.', "::");
        self.0.writeln(w, &format!("use crate::{};", rust_path))?;
        Ok(())
    }

    fn gen_msg_begin(
        &mut self,
        _: &ir::Schema,
        msg: &ir::Message,
        w: &mut W,
    ) -> anyhow::Result<()> {
        // Doc comment
        self.0.comment_opt(w, msg.doc.as_deref())?;

        // Struct definition
        self.0.writeln(w, "#[derive(Debug, Clone, PartialEq)]")?;
        self.0.writeln(w, &format!("pub struct {} {{", msg.name))?;
        self.0.indent();

        Ok(())
    }

    fn gen_msg_end(
        &mut self,
        _: &ir::Schema,
        msg: &ir::Message,
        w: &mut W,
    ) -> anyhow::Result<()> {
        // Compute defaults before borrowing to avoid borrow conflicts
        let defaults: Vec<_> = msg
            .fields
            .iter()
            .map(|f| (f.name.clone(), self.default_value(&f.encoding.native)))
            .collect();

        // Close struct
        self.0.outdent();
        self.0.writeln(w, "}")?;
        self.0.blank_line(w)?;

        // Impl block
        self.0.writeln(w, &format!("impl {} {{", msg.name))?;
        self.0.indent();

        // Constructor
        self.0.comment(w, "Creates a new instance with default values.")?;
        self.0.writeln(w, "pub fn new() -> Self {")?;
        self.0.indent();
        self.0.writeln(w, "Self {")?;
        self.0.indent();

        for (name, default) in defaults {
            self.0.writeln(w, &format!("{}: {},", name, default))?;
        }

        self.0.outdent();
        self.0.writeln(w, "}")?;
        self.0.outdent();
        self.0.writeln(w, "}")?;
        self.0.blank_line(w)?;

        // Encode stub
        self.0.comment(w, "Encodes this message to a writer.")?;
        self.0.writeln(
            w,
            "pub fn encode(&self, _writer: &mut [u8]) -> std::io::Result<()> {",
        )?;
        self.0.indent();
        self.0.writeln(w, "todo!(\"serialization not yet implemented\")")?;
        self.0.outdent();
        self.0.writeln(w, "}")?;
        self.0.blank_line(w)?;

        // Decode stub
        self.0.comment(w, "Decodes a message from a reader.")?;
        self.0.writeln(
            w,
            "pub fn decode(_reader: &[u8]) -> std::io::Result<Self> {",
        )?;
        self.0.indent();
        self.0.writeln(w, "todo!(\"deserialization not yet implemented\")")?;
        self.0.outdent();
        self.0.writeln(w, "}")?;

        // Close impl block
        self.0.outdent();
        self.0.writeln(w, "}")?;
        self.0.blank_line(w)?;

        // Default impl
        self.0.writeln(w, &format!("impl Default for {} {{", msg.name))?;
        self.0.indent();
        self.0.writeln(w, "fn default() -> Self {")?;
        self.0.indent();
        self.0.writeln(w, "Self::new()")?;
        self.0.outdent();
        self.0.writeln(w, "}")?;
        self.0.outdent();
        self.0.writeln(w, "}")?;
        self.0.blank_line(w)?;

        Ok(())
    }

    fn gen_enum_begin(
        &mut self,
        _: &ir::Schema,
        e: &ir::Enum,
        w: &mut W,
    ) -> anyhow::Result<()> {
        // Doc comment
        self.0.comment_opt(w, e.doc.as_deref())?;

        // Enum definition
        self.0.writeln(w, "#[derive(Debug, Clone, Copy, PartialEq, Eq)]")?;
        self.0.writeln(w, &format!("pub enum {} {{", e.name))?;
        self.0.indent();

        Ok(())
    }

    fn gen_enum_end(&mut self, _: &ir::Schema, _: &ir::Enum, w: &mut W) -> anyhow::Result<()> {
        // Close enum
        self.0.outdent();
        self.0.writeln(w, "}")?;
        self.0.blank_line(w)?;

        Ok(())
    }

    fn gen_field(
        &mut self,
        _: &ir::Schema,
        field: &ir::Field,
        current_pkg: &str,
        w: &mut W,
    ) -> anyhow::Result<()> {
        // Doc comment
        self.0.comment_opt(w, field.doc.as_deref())?;

        // Field declaration
        let rust_type = self.type_name(&field.encoding.native, current_pkg);
        self.0.writeln(w, &format!("pub {}: {},", field.name, rust_type))?;

        Ok(())
    }

    fn gen_variant(
        &mut self,
        _: &ir::Schema,
        variant: &ir::Variant,
        current_pkg: &str,
        w: &mut W,
    ) -> anyhow::Result<()> {
        match variant {
            ir::Variant::Unit { name, doc, .. } => {
                self.0.comment_opt(w, doc.as_deref())?;
                self.0.writeln(w, &format!("{},", name))?;
            }
            ir::Variant::Field {
                name, field, doc, ..
            } => {
                self.0.comment_opt(w, doc.as_deref())?;
                let rust_type = self.type_name(&field.encoding.native, current_pkg);
                self.0.writeln(w, &format!("{}({}),", name, rust_type))?;
            }
        }

        Ok(())
    }
}

/* ------------------------------- Impl: Rust ------------------------------- */

impl Rust {
    /// Converts a descriptor string to a Rust type name.
    fn descriptor_to_rust_type(&self, descriptor: &str, current_package: &str) -> String {
        let parts: Vec<&str> = descriptor.split('.').collect();
        let current_pkg_parts: Vec<&str> = current_package.split('.').collect();

        let is_same_package = parts.len() > current_pkg_parts.len()
            && parts[..current_pkg_parts.len()] == current_pkg_parts[..];

        if is_same_package {
            // Same package - use simple name (nested types are inlined)
            parts.last().copied().unwrap_or(descriptor).to_string()
        } else {
            // Cross-package reference - use crate:: qualified path
            format!("crate::{}", parts.join("::"))
        }
    }

    /// Converts an IR NativeType to a Rust type string.
    pub fn type_name(&self, native: &ir::NativeType, current_package: &str) -> String {
        match native {
            ir::NativeType::Bool => "bool".to_string(),
            ir::NativeType::Int { bits, signed } => {
                let prefix = if *signed { "i" } else { "u" };
                format!("{}{}", prefix, bits)
            }
            ir::NativeType::Float { bits } => format!("f{}", bits),
            ir::NativeType::String => "String".to_string(),
            ir::NativeType::Bytes => "Vec<u8>".to_string(),
            ir::NativeType::Array { element } => {
                let inner = self.type_name(&element.native, current_package);
                format!("Vec<{}>", inner)
            }
            ir::NativeType::Map { key, value } => {
                let key_type = self.type_name(&key.native, current_package);
                let value_type = self.type_name(&value.native, current_package);
                format!("HashMap<{}, {}>", key_type, value_type)
            }
            ir::NativeType::Message { descriptor } => {
                self.descriptor_to_rust_type(descriptor, current_package)
            }
            ir::NativeType::Enum { descriptor } => {
                self.descriptor_to_rust_type(descriptor, current_package)
            }
        }
    }

    /// Returns a default value expression for a NativeType.
    pub fn default_value(&self, native: &ir::NativeType) -> String {
        match native {
            ir::NativeType::Bool => "false".to_string(),
            ir::NativeType::Int { .. } => "0".to_string(),
            ir::NativeType::Float { .. } => "0.0".to_string(),
            ir::NativeType::String => "String::new()".to_string(),
            ir::NativeType::Bytes => "Vec::new()".to_string(),
            ir::NativeType::Array { .. } => "Vec::new()".to_string(),
            ir::NativeType::Map { .. } => "HashMap::new()".to_string(),
            ir::NativeType::Message { descriptor } => {
                let type_name = descriptor.split('.').last().unwrap_or(descriptor);
                format!("{}::new()", type_name)
            }
            ir::NativeType::Enum { descriptor } => {
                let type_name = descriptor.split('.').last().unwrap_or(descriptor);
                format!("{}::default()", type_name)
            }
        }
    }
}

/* -------------------------------------------------------------------------- */
/*                               Function: rust                               */
/* -------------------------------------------------------------------------- */

pub fn rust<W: Writer>() -> impl Generator<W> {
    Rust::default()
}
